diff --git a/kernel/bio.c b/kernel/bio.c
index 532832a..b83a01c 100644
--- a/kernel/bio.c
+++ b/kernel/bio.c
@@ -25,33 +25,29 @@
 
 #define NBUCKETS 13
 
-// 修改bcache的结构 变成hash table
 struct {
-  struct spinlock lock;
+  struct spinlock lock[NBUCKETS];
   struct buf buf[NBUF];
-
-  // Linked list of all buffers, through prev/next.
-  // Sorted by how recently the buffer was used.
-  // head.next is most recent, head.prev is least.
-  struct buf head;
+  struct buf hashbucket[NBUCKETS];
 } bcache;
 
 void binit(void)
 {
-  // TODO: modify here
   struct buf *b;
 
-  initlock(&bcache.lock, "bcache");
+  for (int i = 0; i < NBUCKETS; i++) {
+    initlock(&bcache.lock[i], "bcache");
+    bcache.hashbucket[i].prev = &bcache.hashbucket[i];
+    bcache.hashbucket[i].next = &bcache.hashbucket[i];  
+  }
 
-  // Create linked list of buffers
-  bcache.head.prev = &bcache.head;
-  bcache.head.next = &bcache.head;
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
+  for (b = bcache.buf; b < bcache.buf + NBUF; b++) {
+    int bucket = (b-bcache.buf) % NBUCKETS;
+    b->next = bcache.hashbucket[bucket].next;
+    b->prev = &bcache.hashbucket[bucket];
     initsleeplock(&b->lock, "buffer");
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
+    bcache.hashbucket[bucket].next->prev = b;
+    bcache.hashbucket[bucket].next = b;
   }
 }
 
@@ -59,34 +55,88 @@ void binit(void)
 // If not found, allocate a buffer.
 // In either case, return locked buffer.
 static struct buf* bget(uint dev, uint blockno) {
-  // TODO: 修改bget() 和 brelse() 使得缓存区并发的查询和释放不容易发生锁争用
   struct buf *b;
+  int hash_index = blockno % NBUCKETS;
+  acquire(&bcache.lock[hash_index]);
 
-  acquire(&bcache.lock);
-
-  // Is the block already cached?
-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
-    if(b->dev == dev && b->blockno == blockno){
+  // cached
+  for (b = bcache.hashbucket[hash_index].next; b != &bcache.hashbucket[hash_index]; b = b->next) {
+    if (b->dev == dev && b->blockno == blockno) {
       b->refcnt++;
-      release(&bcache.lock);
+      release(&bcache.lock[hash_index]);
       acquiresleep(&b->lock);
       return b;
     }
   }
 
-  // Not cached.
-  // Recycle the least recently used (LRU) unused buffer.
-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
-    if(b->refcnt == 0) {
+  // Not cached
+  for (b = bcache.hashbucket[hash_index].prev; b != &bcache.hashbucket[hash_index]; b = b->prev) {
+    if (b->refcnt == 0) {
       b->dev = dev;
       b->blockno = blockno;
       b->valid = 0;
       b->refcnt = 1;
-      release(&bcache.lock);
+      release(&bcache.lock[hash_index]);
       acquiresleep(&b->lock);
       return b;
     }
   }
+  // 查找其他哈希桶中的空闲缓存块
+  release(&bcache.lock[hash_index]);
+
+  // 使用临时缓存块指针
+  struct buf *free_buf = 0;
+
+  // 遍历所有哈希桶，排除当前哈希桶
+  for (int i = 0; i < NBUCKETS; i++) {
+    if (i == hash_index) continue;  // 跳过当前哈希桶
+
+    acquire(&bcache.lock[i]);
+
+    // 在哈希桶 i 中寻找空闲的缓存块
+    for (b = bcache.hashbucket[i].prev; b != &bcache.hashbucket[i]; b = b->prev) {
+        if (b->refcnt == 0) {
+        free_buf = b;  // 找到一个空闲块
+        break;  // 找到后跳出内层循环
+    }
+  }
+
+    release(&bcache.lock[i]);  // 释放当前哈希桶的锁
+
+    if (free_buf) {
+      // 找到空闲块后，退出外层循环
+      break;
+    }
+  }
+
+  if (!free_buf) {
+    panic("bget: no buffers");  // 没有找到空闲缓存块，报错
+  }
+
+  // 更新找到的空闲缓存块
+  free_buf->dev = dev;
+  free_buf->blockno = blockno;
+  free_buf->valid = 0;
+  free_buf->refcnt = 1;
+
+  // 将缓存块从原哈希桶中移除
+  struct buf *prev = free_buf->prev;
+  struct buf *next = free_buf->next;
+  prev->next = next;
+  next->prev = prev;
+
+  // 将缓存块插入到目标哈希桶
+  acquire(&bcache.lock[hash_index]);
+  free_buf->next = bcache.hashbucket[hash_index].next;
+  free_buf->prev = &bcache.hashbucket[hash_index];
+  bcache.hashbucket[hash_index].next->prev = free_buf;
+  bcache.hashbucket[hash_index].next = free_buf;
+  release(&bcache.lock[hash_index]);
+
+  // 获取该缓存块的睡眠锁并返回
+  acquiresleep(&free_buf->lock);
+  return free_buf;
+
   panic("bget: no buffers");
 }
 
@@ -115,41 +165,43 @@ bwrite(struct buf *b)
 
 // Release a locked buffer.
 // Move to the head of the most-recently-used list.
-void
+void 
 brelse(struct buf *b)
 {
-  if(!holdingsleep(&b->lock))
+  if (!holdingsleep(&b->lock))
     panic("brelse");
 
   releasesleep(&b->lock);
 
-  acquire(&bcache.lock);
+  int hash_index = b->blockno % NBUCKETS;
+  acquire(&bcache.lock[hash_index]);
+
   b->refcnt--;
   if (b->refcnt == 0) {
-    // no one is waiting for it.
     b->next->prev = b->prev;
     b->prev->next = b->next;
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
+    b->next = bcache.hashbucket[hash_index].next;
+    b->prev = &bcache.hashbucket[hash_index];
+    bcache.hashbucket[hash_index].next->prev = b;
+    bcache.hashbucket[hash_index].next = b;
   }
-  
-  release(&bcache.lock);
+  release(&bcache.lock[hash_index]);
 }
 
-void
+void 
 bpin(struct buf *b) {
-  acquire(&bcache.lock);
+  int hash_index = b->blockno % NBUCKETS;
+  acquire(&bcache.lock[hash_index]);
   b->refcnt++;
-  release(&bcache.lock);
+  release(&bcache.lock[hash_index]);
 }
 
-void
+void 
 bunpin(struct buf *b) {
-  acquire(&bcache.lock);
+  int hash_index = b->blockno % NBUCKETS;
+  acquire(&bcache.lock[hash_index]);
   b->refcnt--;
-  release(&bcache.lock);
+  release(&bcache.lock[hash_index]);
 }
 
 
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 4a45e1e..54a16db 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -18,27 +18,42 @@ struct run {
   struct run *next;
 };
 
-struct {
+struct kmem{
   struct spinlock lock;
   struct run *freelist;
-} kmem;
+};
+
+struct kmem kmems[NCPU];
 
 void
 kinit()
 {
-  initlock(&kmem.lock, "kmem");
-  freerange(end, (void*)PHYSTOP);
+  for (int i = 0; i < NCPU; i++) {
+    initlock(&kmems[i].lock, "kmem");
+    kmems[i].freelist = 0;  // 初始化每个CPU的freelist为空
+  }
+  freerange(end, (void*)PHYSTOP);  // 为物理内存分配空闲内存
 }
 
-void
+void 
 freerange(void *pa_start, void *pa_end)
 {
   char *p;
+  int cpu = 0;
   p = (char*)PGROUNDUP((uint64)pa_start);
-  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
-    kfree(p);
+  for (; p + PGSIZE <= (char*)pa_end; p += PGSIZE) {
+    struct run *r = (struct run*)p;
+
+    acquire(&kmems[cpu].lock);
+    r->next = kmems[cpu].freelist;
+    kmems[cpu].freelist = r;  // 将内存块放入freelist
+    release(&kmems[cpu].lock);
+
+    cpu = (cpu + 1) % NCPU;  // 将内存分配给不同的CPU
+  }
 }
 
+
 // Free the page of physical memory pointed at by v,
 // which normally should have been returned by a
 // call to kalloc().  (The exception is when
@@ -47,6 +62,7 @@ void
 kfree(void *pa)
 {
   struct run *r;
+  int id = cpuid();
 
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
@@ -55,11 +71,11 @@ kfree(void *pa)
   memset(pa, 1, PGSIZE);
 
   r = (struct run*)pa;
-
-  acquire(&kmem.lock);
-  r->next = kmem.freelist;
-  kmem.freelist = r;
-  release(&kmem.lock);
+  acquire(&kmems[id].lock);
+  r->next = kmems[id].freelist;
+  kmems[id].freelist = r;
+  // 释放锁
+  release(&kmems[id].lock);
 }
 
 // Allocate one 4096-byte page of physical memory.
@@ -67,14 +83,35 @@ kfree(void *pa)
 // Returns 0 if the memory cannot be allocated.
 void *kalloc(void) {
   struct run *r;
+  int id = cpuid();  // 获取当前CPU的ID
   
-  acquire(&kmem.lock);
-  r = kmem.freelist;
-  if(r)
-    kmem.freelist = r->next;
-  release(&kmem.lock);
-
-  if(r)
-    memset((char*)r, 5, PGSIZE); // fill with junk
+  // 从当前CPU的freelist中获取内存块
+  acquire(&kmems[id].lock);
+  r = kmems[id].freelist;
+  if (r) {
+    kmems[id].freelist = r->next;
+  }
+  release(&kmems[id].lock);
+
+  // 如果当前CPU的freelist为空，从其他CPU的freelist窃取内存块
+  if (!r) {
+    for (int i = 0; i < NCPU; i++) {
+      if (i == id) continue;  // 不从自己CPU窃取
+
+      acquire(&kmems[i].lock);
+      if (kmems[i].freelist) {
+        r = kmems[i].freelist;
+        kmems[i].freelist = r->next;
+        release(&kmems[i].lock);
+        break;  // 一旦从其他CPU窃取成功，退出
+      }
+      release(&kmems[i].lock);
+    }
+  }
+
+  if (r) {
+    memset((char*)r, 5, PGSIZE); 
+  }
+
   return (void*)r;
 }
diff --git a/time.txt b/time.txt
index e69de29..7813681 100755
--- a/time.txt
+++ b/time.txt
@@ -0,0 +1 @@
+5
\ No newline at end of file
